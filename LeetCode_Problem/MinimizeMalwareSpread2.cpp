// 928. Minimize Malware Spread II

// You are given a network of n nodes represented as an n x n adjacency matrix graph,
//  where the ith node is directly connected to the jth node if graph[i][j] == 1.

// Some nodes initial are initially infected by malware. Whenever two nodes are 
// directly connected, and at least one of those two nodes is infected by malware,
//  both nodes will be infected by malware. This spread of malware will continue 
// until no more nodes can be infected in this manner.

// Suppose M(initial) is the final number of nodes infected with malware in the 
// entire network after the spread of malware stops.

// We will remove exactly one node from initial, completely removing it and any
//  connections from this node to any other node.

// Return the node that, if removed, would minimize M(initial). If multiple nodes 
// could be removed to minimize M(initial), return such a node with the smallest index.

// Example 1:
// Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
// Output: 0

// Example 2:
// Input: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]
// Output: 1

// Example 3:
// Input: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]
// Output: 1
 
// Constraints:
// n == graph.length
// n == graph[i].length
// 2 <= n <= 300
// graph[i][j] is 0 or 1.
// graph[i][j] == graph[j][i]
// graph[i][i] == 1
// 1 <= initial.length < n
// 0 <= initial[i] <= n - 1
// All the integers in initial are unique.

#include<bits/stdc++.h>
using namespace std;

class Solution {
    unordered_map<int,unordered_set<int>> um;
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int graphLength = graph.size();
        for(int i=0;i<graphLength;i++){
            for(int j=0;j<graphLength;j++){
                if(graph[i][j] && i != j){
                    um[i].insert(j);
                }
            }
        }

        sort(initial.begin(),initial.end());
        int ans;
        int nodeAffected = INT_MAX;
        for(auto var : initial){
            vector<int> visited(graphLength , 0);
            visited[var] = true;
            int infected = 0;
            queue<int> q;
            
            for(auto x : initial){
                if(x != var && visited[x] == 0){
                    visited[x] = 1;
                    q.push(x);
                    infected++;
                }
            }
            while(!q.empty()){
                int front = q.front();
                q.pop();
                for(auto w : um[front]){
                    if(visited[w] == 0){
                        visited[w] = 1;
                        q.push(w);
                        infected++;
                    }
                }
            }
            if(infected < nodeAffected){
                nodeAffected = infected;
                ans = var;
            }
        }
        return ans;
    }
};