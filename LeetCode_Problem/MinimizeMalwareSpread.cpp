// 924. Minimize Malware Spread

// You are given a network of n nodes represented as an n x n adjacency matrix graph, where
//  the ith node is directly connected to the jth node if graph[i][j] == 1.

// Some nodes initial are initially infected by malware. Whenever two nodes are directly
//  connected, and at least one of those two nodes is infected by malware, both nodes will 
// be infected by malware. This spread of malware will continue until no more nodes can be
//  infected in this manner.

// Suppose M(initial) is the final number of nodes infected with malware in the entire 
// network after the spread of malware stops. We will remove exactly one node from initial.

// Return the node that, if removed, would minimize M(initial). If multiple nodes could be
//  removed to minimize M(initial), return such a node with the smallest index.

// Note that if a node was removed from the initial list of infected nodes, it might still
//  be infected later due to the malware spread.

// Example 1:
// Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
// Output: 0

// Example 2:
// Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
// Output: 0

// Example 3:
// Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
// Output: 1
 
// Constraints:
// n == graph.length
// n == graph[i].length
// 2 <= n <= 300
// graph[i][j] is 0 or 1.
// graph[i][j] == graph[j][i]
// graph[i][i] == 1
// 1 <= initial.length <= n
// 0 <= initial[i] <= n - 1
// All the integers in initial are unique.

#include<bits/stdc++.h>
using namespace std;

class Solution {
    int * parent;

    int findParent(int x){
        if(x == parent[x]){
            return x;
        }
        return parent[x] = findParent(parent[x]);
    }

    void merge(int x,int y){
        int xPar = findParent(x);
        int yPar = findParent(y);
        if(xPar != yPar){
            parent[xPar] = yPar;
        }
        return;
    }
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        parent = new int[n];
        for(int i=0;i<n;i++){
            parent[i] = i;
        }

        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(graph[i][j]){
                    merge(i,j);
                }
            }
        }

        vector<int> totalItCanAffect(n,0);
        for(int i=0;i<n;i++){
            totalItCanAffect[findParent(i)]++;
        }

        vector<int> malware(n,0);
        for(auto val : initial){
            malware[findParent(val)]++;
        }

        vector<int> res = {1,0};
        for(auto val: initial){
            res = min(res,{(malware[findParent(val)] == 1) * (-totalItCanAffect[findParent(val)]) ,val});
        }
        return res[1];
    }
};